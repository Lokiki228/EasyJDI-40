# JDI-40_librari
Легкая библиотека для модуля JDI-40, настраиваемый по UART, библиотека написана для легкой настройки модуля из программы(Вы можете и сами это делать без библиотеки, используя AT команды).
Я собрал все это в одну библиотеку. Для более легкой настройки используется класс, так что настройка будет очень легкой. Также добавил еще немного плюшек по типу симплекса и энергосбережения.
## Возможности
### Сейчас
- гибкая настройка модуля из программы
- передача любого Stream объекта
- какое никакое энерго сбережение(актуально только для симплексного режима работы)
- симплексный режим работы UART-моста(в разработке, но уже есть пара методов)
- отчет об успешности выполнения настройки(ТОЛЬКО в режиме настройки через АТ): отправили команду - получаем данные с UART - и понимаем получили или нет
- проверка наличия модуля на шине
### В будующем
- наследование класса print
- получение всех настроек с модуля
- быстрая синхронизация двух систем по проводу(например вемос в связке с jdi), я еще не придумал поэтому не могу описать.
## Совместимость
С ней проблем не должно быть, т.к. используются ардуино функции.
Но для справки! Я тестировал это на esp8266 и lgt8f328. Рекомендуется использовать softSerial, но может и получиться с hardware.
## Скорость
При 9600 бод, setAllSettings выполняется около 400 мс, одиночные настройки выполняются 70 - 80 мс, сами AT команды выполняются быстрее, но у нас же все по-умному).
- Во-первых нужны небольшие зажержки чтобы модуль успел очухаться и понять что он в режиме настройки
- предусмотрел небольшие задержки перед отправкой и после

Где небольшие зажержки - 15 мс.
## Методы
### Конструктор
```cpp
JDI40 jdi(Serial); //в конструктор передаем Stream объект, Serial или SoftSerial, рекомендую softSerial, но может и заработать и без него.
```
Проверено на собственном опыте! Не подключайте модуль к аппаратному Serial esp8266(available был просто пуст), у меня заработал только с программным.
### Проблемы
После setBaud, как минимум 2 настройки не воспринимаются, так что лучше делать setAllSettings или ВООБЩЕ НЕ ИСПОЛЬЗОВАТЬ их. Я постараюсь решить данную проблему. Но пока-что, если необходимо, советую делать боды в конце всех настроек, либо делать setAllSettings, там это предусмотрено.
### Функции
```cpp
void configDevice(bool mode, uint8_t cs, uint8_t set); //Передаем режим(о нем ниже), передаем пин на который цепляем cs, передаем пин на который цепляем set

bool begin(); //проверяет наличие модуля, вернет 1 если все норм

void on(); //включить модуль
void off(); //выключить модуль
//не совсем нужные функции, используются если хотите вручную посылать данные в порт(для передачи) для симплекса, при этом сохранив низкое потребление, о нем ниже 

bool setAllSettings(uint8_t baud, uint16_t rfid, uint16_t dvid, uint8_t rfc, uint8_t power); //передать все настройки модуля: скорость порта,
//ID сети(пока что от 1000 до 9999), ID устройства(пока что от 1000 до 9999), канал связи, и мощность передатчика.
//о диапазонах параметров ниже
//если все хорошо вернет 1

//те же настройки но по отдельности
//вернут единичку если все прошло хорошо
bool setBaud(uint8_t baud); //от 1 до 6
/* скорости в бодах
1 - 1200
2 - 2400
3 - 4800
4 - 9600
5 - 14400
6 - 19200
*/ //по умолчанию 4

bool seRftID(uint16_t rfid); //передаем ID сети(пока что от 1000 до 9999). на деле можно передать 16-ти битные числа
//вернет 1 если все прошло хорошо

bool seDevtID(uint16_t dvid); //ID устройства(пока что от 1000 до 9999). на деле можно передать 16-ти битные числа
//вернет 1 если все прошло хорошо

bool setChannel(uint8_t rfc); //установить канал связи от 0 до 127
//вернет 1 если все прошло хорошо

bool setPower(uint8_t power); //установить мощность передатчика от 0 до 9
//вернет 1 если все прошло хорошо
/*
0 - 25db
1 - 15db
2 - 5db
3 - 0db
4 - 3db
5 - 6db
6 - 9db
7 - 10db
8 - 10db
9 - 12db
*/ //и да 7 и 8 - это не ошибка, по умолчанию стоит 10dB




//Отправка в симплексе
void print(String str); //принимает строку
void print(const char* str); //принимает текст в кавычках типа "бла бла бла"
//тестовые функции, используются для симплекса, при энергосбережении
//тобишь включили чип - отправили данные - выключили чип, например "УМНЫЙ ПУЛЬТ С АРДУИНО"

//coming soon... More, MORE!
```
Буду рад вашим дополнениям к библиотеке, а особенно дополнениям к оптимизации либы и алгоритмам парсинга ответов на запросы установленных параметров с модуля.
А пока...
## Версии
- 1.0 создание и небольшой тест.
## Немного о железке
- Два модуля настроенные на один канал, не будут коннектиться если уних разные ID(неважно устройства или сети), просьба для тех у кого модулей больше 4-х, можно ли использовать 2 модуля настроенными на 120(например) канал, с одним ID и 2 модуля настроенными на 120(например) канал, с другим ID.
- Чето-там около 120м на открытом поле и около 15м через стены, в общем отличное соотношение цена/качество (стоит около 60руб).
- небольшое энергопотребление(40мА в режиме передачи, 24мА в приемке, 5мкА во сне)(ну хотя что небольшое для меня, то для других огромное), спящий режим(используется в режиме симплекса в либе).
- есть 8-ми битный порт ввода-вывода(8 GPIO), в доке написано что железки можно использовать сами по себе, т.е. без МК.

Взято с https://arduinolab.pw/index.php/2019/05/15/radiomoduli-jdy-40-2-4g-s-uart-interfejsom/#more-1515
Для настройки модуля необходимо перевести его в режим конфигурации, для этого необходимо притянуть контакт «SET» к массе. В командном режиме последовательный порт сконфигурирован на 9600bps.

AT+BAUD — Скорость последовательного порта (1,200bps, 2,400bps, 4,800bps, 9,600bps, 19,200bps) По умолчанию — 9,600bps. Пример: «AT+BAUD9600».

AT+RFID — Идентификатор беспроводной сети

AT+DVID — Идентификатор радиомодуля

AT+RFC — Канал беспроводной связи, от 001 до 128. В даташите на модуль не указано соответствие частоты к каналу. В даташите на трансивер указана начальная частота 2400мгц, шаг одного канала 1мгц, но как реализовано на практике, не известно. Пример: «AT+RFC001» вернет «OK»

AT+POWE — Мощность передатчика, от 0 до 9, таблица соответствий ниже. Пример: «AT+POWE8» вернет «OK»

1      	  2	         3	     4	   5	   6	    7	      8	       9
-15dBm    -5dBm	    0dBm	 3dBm	 6dBm	 9dBm   10dBm 	10dBm	   12dBm
(0.03mW)	(0.32mW)	(1mW)	(2mW)	(4 mW) (8mW)	(10mW)	(10mW)	(15.8mW)
AT+CLSS — Режим работы модуля, основных режимов два, радиомодем в котором работает UART и пульт дистанционного управления с различными вариантами работы 8 битного порта с GPIO. Значение по умолчанию: A0. Пример: «AT+CLSSA0» вернет «OK»

A0: прозрачная передача через последовательный порт, режим радиомодема.
C0: Передающий пульт дистанционного управления с индикацией. В этом режиме с 1 по 7 GPIO радиомодуля сконфигурированы на вход для подключения кнопок, 8 GPIO на выход для подключения светодиода индикации передачи.
C1: Передающий пульт дистанционного управления без индикации. В этом режиме все 8 GPIO радиомодуля сконфигурированы на вход для подключения кнопок
C2: Приемник, все 8 GPIO сконфигурированы на выход, на выходах низкий уровень, логический 0, при приеме сигнала соответствующем передатчику GPIO генерируется положительный импульс длительностью 30 мс
C3: Приемник, все 8 GPIO сконфигурированы на выход, на выходах высокий уровень, логический 1, при приеме сигнала соответствующем передатчику GPIO генерируется отрицательный импульс длительностью 30 мс
C4: Приемник, все 8 GPIO сконфигурированы на выход, на выходах низкий уровень, при приеме сигнала соответствующем передатчику GPIO появляется высокий уровень, логический 1, логика работы как у беспроводной кнопки.
C5: Приемник, все 8 GPIO сконфигурированы на выход, при приеме сигнала соответствующем передатчику GPIO инвертируется состояние GPIO приемника, логика работы как у беспроводного переключателя.






